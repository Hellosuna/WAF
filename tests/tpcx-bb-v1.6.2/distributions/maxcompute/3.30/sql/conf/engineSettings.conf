#!/usr/bin/env bash

#
# Copyright (C) 2019 Transaction Processing Performance Council (TPC) and/or its contributors.
# This file is part of a software package distributed by the TPC
# The contents of this file have been developed by the TPC, and/or have been licensed to the TPC under one or more contributor
# license agreements.
# This file is subject to the terms and conditions outlined in the End-User
# License Agreement (EULA) which can be found in this distribution (EULA.txt) and is available at the following URL:
# http://www.tpc.org/TPC_Documents_Current_Versions/txt/EULA.txt
# Unless required by applicable law or agreed to in writing, this software is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, and the user bears the entire risk as to quality
# and performance as well as the entire cost of service or repair in case of defect. See the EULA for more details.
# 
#


#
#Copyright (C) 2019-2022 Alibaba Group Holding Limited.
#

# this is common function to all queries in this engine
query_explain_method () {
    QUERY_SCRIPT="${QUERY_SQL_DIR}/explain_${QUERY_NAME}.sql"

    sed -i s/'${TEMP_TABLE1}'/$TEMP_TABLE1/g $QUERY_SCRIPT
    sed -i s/'${TEMP_TABLE2}'/$TEMP_TABLE2/g $QUERY_SCRIPT
    sed -i s/'${TEMP_TABLE3}'/$TEMP_TABLE3/g $QUERY_SCRIPT
    sed -i s/'${TEMP_TABLE4}'/$TEMP_TABLE4/g $QUERY_SCRIPT
    sed -i s/'${TEMP_TABLE5}'/$TEMP_TABLE5/g $QUERY_SCRIPT
    
    if [ ! -r "$QUERY_SCRIPT" ]
    then
    echo "SQL file $QUERY_SCRIPT can not be read."
    exit 1
    fi
    
    runCmdWithErrorCheck runEngineCmd -f "$QUERY_SCRIPT"
    return $?
}
# this function is a wrapper for the default engine command (like "hive")
# it assures that the environment (e.g., binary parameters, init sql files) is properly set
runEngineCmd () {
    echo ""$BINARY" "${BINARY_PARAMS[@]}" "$@""
    "$BINARY" "${BINARY_PARAMS[@]}" "$@"
}


loadUserQueryParameters () {
  if [[ ! -n $QUERY_NAME  ]]
  then
    return 0
  fi

  sed -i 's/SET /set /g' $USER_QUERY_PARAMS_FILE
  PARAMETER_NUMBER=`grep $QUERY_NAME $USER_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|wc -l`
  if [[ $PARAMETER_NUMBER -gt 0 ]]
  then
    for m in `seq 1 $PARAMETER_NUMBER`
    do
      PARAMETER=`grep $QUERY_NAME $USER_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|awk -F ';' '{print $1}'|head -n $m|tail -n 1 |awk -F '=' '{print $1}'`
      VALUE=`grep $QUERY_NAME $USER_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|awk -F ';' '{print $1}'|head -n $m|tail -n 1|awk -F '=' '{print $2}'`
      var='${'$PARAMETER'}'
      #replace the query parameter with the real value in sql script
      sed -i s/"$var"/"$VALUE"/g $QUERY_SQL_DIR/*.sql
    done
  fi
}


loadQueryParameters () {
  if [[ ! -n $QUERY_NAME  ]]
  then
    return 0
  fi
  
  sed -i 's/SET /set /g' $BIG_BENCH_QUERY_PARAMS_FILE
  PARAMETER_NUMBER=`grep $QUERY_NAME $BIG_BENCH_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|wc -l`
  if [[ $PARAMETER_NUMBER -gt 0 ]]
  then
    for m in `seq 1 $PARAMETER_NUMBER`
    do
      PARAMETER=`grep $QUERY_NAME $BIG_BENCH_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|awk -F ';' '{print $1}'|head -n $m|tail -n 1 |awk -F '=' '{print $1}'`
      VALUE=`grep $QUERY_NAME $BIG_BENCH_QUERY_PARAMS_FILE |awk -F 'set ' '{print $2}'|awk -F ';' '{print $1}'|head -n $m|tail -n 1|awk -F '=' '{print $2}'`
      var='${'$PARAMETER'}'
      #replace the query parameter with the real value in sql script
        sed -i s/"$var"/"$VALUE"/g $QUERY_SQL_DIR/*.sql
    done
  fi
}

# sets up the environment when a query is to be executed
initQueryEnv () {
  if [ -z "$QUERY_NUMBER" ]
  then
    echo "The query number must be set."
    return 1
  fi

  if [ $QUERY_NUMBER -lt 1 ]
  then
    echo "Query number must be greater than 0"
    return 1
  fi

  if [ $QUERY_NUMBER -lt 10 ]
  then
    export QUERY_NAME=q0$QUERY_NUMBER
  else
    export QUERY_NAME=q$QUERY_NUMBER
  fi

  QUERY_DIR="$BIG_BENCH_QUERIES_DIR/$QUERY_NAME"
  if [ ! -d "$QUERY_DIR" ]
  then
    echo "Query directory $QUERY_DIR does not exist"
    return 1
  fi

  VALIDATION_RESULTS_DIR="$QUERY_DIR/results"
  if [ ! -d "$VALIDATION_RESULTS_DIR" ]
  then
    echo "Validation results directory $VALIDATION_RESULTS_DIR does not exist"
    return 1
  fi
  VALIDATION_RESULTS_FILENAME="$VALIDATION_RESULTS_DIR/$QUERY_NAME-result"

  # QUERY_DIR is set earlier in this method.
  # Therefore LOCAL_QUERY_ENGINE_SETTINGS_FILE can only be set here and not outside in the global part
  LOCAL_QUERY_ENGINE_SETTINGS_FILE="$QUERY_DIR/engineLocalSettings.sql"

  TABLE_PREFIX="${QUERY_NAME}_${BIG_BENCH_ENGINE}_${BIG_BENCH_BENCHMARK_PHASE}_${BIG_BENCH_STREAM_NUMBER}"

  RESULT_TABLE="${TABLE_PREFIX}_result"
  RESULT_DIR="$BIG_BENCH_HDFS_ABSOLUTE_QUERY_RESULT_DIR/$RESULT_TABLE"
  TEMP_TABLE="${TABLE_PREFIX}_temp"
  TEMP_DIR="$BIG_BENCH_HDFS_ABSOLUTE_TEMP_DIR/$TEMP_TABLE"

  LOG_FILE_NAME="$BIG_BENCH_LOGS_DIR/${TABLE_PREFIX}.log"
  EXPLAIN_LOG_FILE_NAME="$BIG_BENCH_LOGS_DIR/explain_${TABLE_PREFIX}.log"

  # source run.sh as late as possible to allow run.sh to use all above defined variables
  SCRIPT_FILENAME="$QUERY_DIR/run.sh"
  if [ -r "$SCRIPT_FILENAME" ]
  then
    source "$SCRIPT_FILENAME"
  else
    echo "File $SCRIPT_FILENAME containing main method not found, aborting script."
    return 1
  fi

  # check if the main method was implemented properly in the run.sh
  QUERY_MAIN_METHOD="query_run_main_method"
  if ! declare -F "$QUERY_MAIN_METHOD" > /dev/null 2>&1
  then
    echo "$QUERY_MAIN_METHOD was not implemented, aborting script"
    return 1
  fi


  # check if the explain method was implemented properly
  QUERY_EXPLAIN_METHOD="query_explain_method"
  if ! declare -F "$QUERY_EXPLAIN_METHOD" > /dev/null 2>&1
  then
    echo "$QUERY_EXPLAIN_METHOD was not implemented, aborting script"
    return 1
  fi


  # check if the clean method was implemented properly in the run.sh
  QUERY_CLEAN_METHOD="query_run_clean_method"
  if ! declare -F "$QUERY_CLEAN_METHOD" > /dev/null 2>&1
  then
    echo "$QUERY_CLEAN_METHOD was not implemented, aborting script"
    return 1
  fi

  # check if the validate method was implemented properly in the run.sh
  QUERY_VALIDATE_METHOD="query_run_validate_method"
  if ! declare -F "$QUERY_VALIDATE_METHOD" > /dev/null 2>&1
  then
    echo "$QUERY_VALIDATE_METHOD was not implemented, aborting script"
    return 1
  fi
  return 0
}

prepareQuery (){
  JAR_ALIAS_UDTF="${TABLE_PREFIX}_udtf.jar"
  JAR_ALIAS_UDTF_ODPS="${TABLE_PREFIX}_udtf_odps.jar"
  JAR_ALIAS_OPENNLP_MAXENT="${TABLE_PREFIX}_opennlp_maxent.jar"
  JAR_ALIAS_OPENNLP_TOOLS="${TABLE_PREFIX}_opennlp_tools.jar"
  LOCAL_QUERY_ENGINE_SETTINGS_CONF_FILE="$QUERY_DIR/engineLocalSettings.conf"

  if [ -s "$LOCAL_QUERY_ENGINE_SETTINGS_CONF_FILE" ]
  then
    source $LOCAL_QUERY_ENGINE_SETTINGS_CONF_FILE
  fi

  export QUERY_SQL_DIR=$BIG_BENCH_QUERIES_TEMP_DIR/${QUERY_NAME}_${BIG_BENCH_ENGINE}_${BIG_BENCH_BENCHMARK_PHASE}_${BIG_BENCH_STREAM_NUMBER}
  if [ ! -d "$QUERY_SQL_DIR" ]; then
    mkdir -p $QUERY_SQL_DIR
  fi
  cp $BIG_BENCH_QUERIES_DIR/$QUERY_NAME/*.sql $QUERY_SQL_DIR
  echo "============================"
  echo  $QUERY_SQL_DIR
  echo "============================"
  var='${'$PARAMETER'}'
  sed -i s@'${BIG_BENCH_QUERIES_DIR}'@$BIG_BENCH_QUERIES_DIR@g $QUERY_SQL_DIR/*.sql
  sed -i s@'${BIG_BENCH_QUERY_RESOURCES}'@${BIG_BENCH_QUERY_RESOURCES}@g $QUERY_SQL_DIR/*.sql
  sed -i s/'${RESULT_TABLE}'/$RESULT_TABLE/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${TEMP_TABLE}'/$TEMP_TABLE/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${JAR_ALIAS_UDTF}'/$JAR_ALIAS_UDTF/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${JAR_ALIAS_UDTF_ODPS}'/$JAR_ALIAS_UDTF_ODPS/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${JAR_ALIAS_OPENNLP_MAXENT}'/$JAR_ALIAS_OPENNLP_MAXENT/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${JAR_ALIAS_OPENNLP_TOOLS}'/$JAR_ALIAS_OPENNLP_TOOLS/g $QUERY_SQL_DIR/*.sql
  sed -i s/'${PREFIX}'/$TABLE_PREFIX/g $QUERY_SQL_DIR/*.sql
  sed -i s@'${QUERY_DIR}'@$QUERY_DIR@g $QUERY_SQL_DIR/*.sql  

  # set ODPS local parameters(engineLocalSettings.sql) in array for each query
  if [[ -n "$LOCAL_QUERY_ENGINE_SETTINGS_FILE" && -s "$LOCAL_QUERY_ENGINE_SETTINGS_FILE" ]]
  then
    echo "Additional local ODPS settings found. Setting $LOCAL_QUERY_ENGINE_SETTINGS_FILE parameters to query."
    local IFS=$'\n'
    LOCAL_QUERY_ENGINE_SETTINGS_ITEMS=(`grep -vE "\-\-|^$" ${LOCAL_QUERY_ENGINE_SETTINGS_FILE} | grep -o "[^ ]\+\( \+[^ ]\+\)*"`)
    for item in ${LOCAL_QUERY_ENGINE_SETTINGS_ITEMS[@]}
    do
        sed -i "1i ${item}" $QUERY_SQL_DIR/${QUERY_NAME}*.sql
    done
  fi

  # If user defined ODPS engine settings file exist, set user defined ODPS engine settings in array for each query
  if [ -n "$USER_ENGINE_SETTINGS_FILE" ]
  then
    if [ -r "$USER_ENGINE_SETTINGS_FILE" ]
    then
      echo "User defined engine settings file found. Adding user defined ODPS engine settings"
      local IFS=$'\n'
      USER_ENGINE_SETTINGS_FILE_ITEMS=(`grep -vE "\-\-|^$" ${USER_ENGINE_SETTINGS_FILE} | grep -o "[^ ]\+\( \+[^ ]\+\)*"`)
      for item in ${USER_ENGINE_SETTINGS_FILE_ITEMS[@]}
      do
          sed -i "1i ${item}" $QUERY_SQL_DIR/${QUERY_NAME}*.sql
      done
    else
      echo "User settings file $USER_ENGINE_SETTINGS_FILE can not be read."
      return 1
    fi
  fi

  # set ODPS global parameters(engineSettings.sql) in array for each query
  local IFS=$'\n'
  BIG_BENCH_ENGINE_SETTINGS_FILE_ITEMS=(`sed s/'${BIG_BENCH_DATABASE}'/$BIG_BENCH_DATABASE/g ${BIG_BENCH_ENGINE_SETTINGS_FILE} | grep -vE "\-\-|^$" | grep -o "[^ ]\+\( \+[^ ]\+\)*"`)
  for item in ${BIG_BENCH_ENGINE_SETTINGS_FILE_ITEMS[@]}
  do
      sed -i "1i ${item}" $QUERY_SQL_DIR/${QUERY_NAME}*.sql
      sed -i "1i ${item}" $QUERY_SQL_DIR/explain_${QUERY_NAME}*.sql
  done


  # set ODPS query parameters, if user defined quary parameters file exists, load user defined query parameters first.
  if [ -n "$USER_QUERY_PARAMS_FILE" ]
  then
    if [ -r "$USER_QUERY_PARAMS_FILE" ]
    then
      echo "User defined query parameter file found. Using user defined query parameters."
      loadUserQueryParameters
      loadQueryParameters
    else
      echo "User query parameter file $USER_QUERY_PARAMS_FILE can not be read."
      return 1
    fi
  else
    loadQueryParameters
  fi

}

prepareLoad (){
   
   HDFS_DATA_PATH="$HDFS_PATH/$BIG_BENCH_HDFS_ABSOLUTE_INIT_DATA_DIR"
   if [ ! -d "$BIG_BENCH_ENGINE_TEMP_DIR" ]; then
      mkdir -p $BIG_BENCH_ENGINE_TEMP_DIR
   fi
   cp $BIG_BENCH_POPULATE_METASTORE_FILE $BIG_BENCH_ENGINE_TEMP_DIR/odpsCreateLoad_run.sql
   sed -i s@'${HDFS_DATA_PATH}'@$HDFS_DATA_PATH@g $BIG_BENCH_ENGINE_TEMP_DIR/odpsCreateLoad_run.sql
   # set ODPS global parameters(engineSettings.sql) in array for load
   local IFS=$'\n'
   BIG_BENCH_ENGINE_SETTINGS_FILE_ITEMS=(`sed s/'${BIG_BENCH_DATABASE}'/$BIG_BENCH_DATABASE/g ${BIG_BENCH_ENGINE_SETTINGS_FILE} | grep -vE "\-\-|^$" | grep -o "[^ ]\+\( \+[^ ]\+\)*"`)
   for item in ${BIG_BENCH_ENGINE_SETTINGS_FILE_ITEMS[@]}
   do
     sed -i "1i ${item}" $BIG_BENCH_ENGINE_TEMP_DIR/odpsCreateLoad_run.sql
   done

}


export BIG_BENCH_ENGINE_BIN_DIR="$BIG_BENCH_ENGINE_DIR/bin"
export BIG_BENCH_ENGINE_TEMP_DIR="$BIG_BENCH_ENGINE_DIR/tmp"
export BIG_BENCH_QUERIES_DIR="$BIG_BENCH_ENGINE_DIR/queries"
export BIG_BENCH_QUERIES_TEMP_DIR="$BIG_BENCH_ENGINE_TEMP_DIR/queries_tmp"
export BIG_BENCH_CLEAN_DIR="$BIG_BENCH_ENGINE_DIR/clean"
export BIG_BENCH_POPULATION_DIR="$BIG_BENCH_ENGINE_DIR/population"
export BIG_BENCH_REFRESH_DIR="$BIG_BENCH_ENGINE_DIR/refresh"

export BIG_BENCH_CLEAN_METASTORE_FILE="$BIG_BENCH_CLEAN_DIR/dropTables.sql"
export BIG_BENCH_POPULATE_METASTORE_FILE="${USER_POPULATE_FILE:-"$BIG_BENCH_POPULATION_DIR/odpsCreateLoad.sql"}"
export BIG_BENCH_REFRESH_METASTORE_FILE="${USER_REFRESH_FILE:-"$BIG_BENCH_REFRESH_DIR/hiveRefreshCreateLoad.sql"}"
export BIG_BENCH_QUERY_PARAMS_FILE="$BIG_BENCH_ENGINE_CONF_DIR/queryParameters.sql"
export BIG_BENCH_ENGINE_SETTINGS_FILE="$BIG_BENCH_ENGINE_CONF_DIR/engineSettings.sql"

for REQUIRED_FILE in "$BIG_BENCH_CLEAN_METASTORE_FILE" "$BIG_BENCH_POPULATE_METASTORE_FILE" "$BIG_BENCH_REFRESH_METASTORE_FILE" "$BIG_BENCH_QUERY_PARAMS_FILE" "$BIG_BENCH_ENGINE_SETTINGS_FILE"
do
  if [ ! -f "$REQUIRED_FILE" ]
  then
    echo "Required file $REQUIRED_FILE not found"
    exit 1
  fi
done

## ==========================
## HIVE (recommended minimum version v0.13)
## ==========================
#-----------------------------
# Storage formats for: LOAD_STAGE tables,  temporary tables in queries and the query results
#-----------------------------

#LOAD_STAGE file format
#choices are: TEXTFILE, RCFILE, ORC, SEQUENCEFILE, PARQUET, AVRO or: "INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname"
export BIG_BENCH_hive_default_fileformat_source_table="ORC"

#Temporary Tables file format inside the queries.
#choices are:  TextFile, SequenceFile, RCfile, and ORC.
#"BIG_BENCH_hive_default_fileformat_tmp_table" is used to override "hive.default.fileformat"
#(PARQUET is NOT! supported here. This is a limitiation of hive, as hive.default.fileformat only accepts the listed options)
# => all "CREATE <TEMPORARY> TABLE" statements within the queries will use the specified fileformat during bigbench execution (except the "result" table)
export BIG_BENCH_hive_default_fileformat_tmp_table="TEXTFILE"

#Query result table format
#do not modify "_result_table" file format! Final query result has to be kept human readable!
export BIG_BENCH_hive_default_fileformat_result_table="TEXTFILE"


BINARY="/home/admin/odps_clt/bin/odpscmd"
BINARY_PARAMS=()

#ML framework used to execute ML-algorithm parts of queries (Naive Bayes, KMeans, Logistic regression)
export BIG_BENCH_ENGINE_HIVE_ML_FRAMEWORK="odps"

#Binary and launch parameters for Spark used to execute the machine learning part of the queries.
#export BIG_BENCH_ENGINE_HIVE_ML_FRAMEWORK_SPARK_BINARY="spark-submit --deploy-mode cluster --master yarn"
export BIG_BENCH_ENGINE_HIVE_ML_FRAMEWORK_SPARK_BINARY="spark-submit"

## Kmeans fails when running on HDFS and execution mode "mapreduce" https://issues.apache.org/jira/browse/MAHOUT-1658
export BIG_BENCH_ENGINE_HIVE_MAHOUT_EXECUTION="sequential"

# ODPS settings for loading data from HDFS to ODPS
# Test sponsor should enter HDFS path to their externally generated data
export HDFS_PATH=""
