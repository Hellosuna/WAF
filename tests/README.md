<<<<<<< HEAD
# tests
## Data generation
Six UDFs were tested, and the table data related to the query was obtained from two benchmarks, TPCx-BB and TPC-H. The TPC test package is available on its website (https://www.tpc.org/).
### 1. TPC-H
After downloading code, we need to compile the dbgen executable file, then generate table data, can be the reference document(https://blog.csdn.net/qq_38688267/article/details/122535189). <br>
`dbgen -f -s 1`   //generate 1G data  
### 2. TPCx-BB
The data generated by TPCx-BB needs to be in the hadoop+hive/spark environment, so the deployment process is unnecessary. In addition, some environment variables need to be set to bind to hadoop and hive.<br>
`bigBench runBenchmark -f 1 -i CLEAN_DATA,DATA_GENERATION`   //generate 1G data,only run data clean and data generation stage.
## Environment
### 1. database
Build GreenPlum(https://github.com/greenplum-db/gpdb-archive), After that, we can import the above generated table data into the database (our greenplum is built locally, 1 coordinator, 2 segments).
### 2. wasm environment
The wasm compiler used is our custom clang, and the wasm runtime is wamr with shared memory.
### 3. docker install
### 4. Serialization tools
Use Google flatbuffer accomplish serialization and deserialization (https://github.com/google/flatbuffers).
## UDF
GreenPlum allows extensions to be written in multiple languages, we use C/C++ and we define the wasm_engine extension that handles communication with wasm or containers.<br>
`cd tests/wasm_engine`  
`make`  
`make install` //install extension<br>  
In tests/wasm_engine/wasm_engine.cpp, we can see that each function logic has four implementation, which are native, docker serialization, wasm serialization, and wasm shared memory.  
### 1. native
Native code, function logic is defined directly in wasm_engine.cpp, see _native suffix function
### 2. docker udf
In tests/docker_udf, 6 UDFs are packed into 6 images.<br> 
For example, build sum image:<br>
`cd sum`  
`docker build -t sum ./`  <br>
The greenplum server and the container communicate via in-memory filesystems, so we'll create an in-memory filesystem and mount it when the container starts  
`sudo mount -t tmpfs -o size=64M tmpfs /mnt/ramdisk_segment_0`  
`docker run -it  --hostname vkernel --network host -v /mnt/ramdisk_segment_0:/mnt/ramdisk sum`  
Greenplum queries are distributed over multiple segment nodes. To avoid segment nodes contending for memory files, a tmpfs(segment suffix -1 to 1) is created and mounted for each segment node.<br>
Communicating with these containers is the _with_docker suffix function from wasm_engine.cpp.
### 3. wasm udf
In tests/wasm_udf, there are 6 functions (.cpp), which were compiled to wasm using clang
`cmake ./`  
`make`  
It is compiled to aot using wamrc. <br>
`cd wasm`  
`make`  
It is the _share and _with_ser suffix functions in wasm_engine.cpp that parse these aot files and perform wasm module validation, instantiate, and call these wasm functions.<br>
As you can see, in each cpp file under tests/wasm_udf there are two functions, one to transfer data in shared memory mode and another to transfer data using flatbuffer serialization/deserialization.<br>
## SQL query execution
There are 6 sql queries in tests/sql (extracted from TPC-H and TPCx-BB):<br>
`psql -p 15432 -d postgres -f tests/sql/sum.sql`   
After the query is executed, the time consumption of each part of the UDF execution is printed as a log.
