diff --git a/clang/lib/CodeGen/CGBuilder.h b/clang/lib/CodeGen/CGBuilder.h
index 2fcfea64e..614205caa 100644
--- a/clang/lib/CodeGen/CGBuilder.h
+++ b/clang/lib/CodeGen/CGBuilder.h
@@ -260,6 +260,7 @@ public:
 
   /// Create GEP with single dynamic index. The address alignment is reduced
   /// according to the element size.
+  using CGBuilderBaseTy::CreateCall;
   using CGBuilderBaseTy::CreateGEP;
   Address CreateGEP(Address Addr, llvm::Value *Index,
                     const llvm::Twine &Name = "") {
@@ -267,10 +268,18 @@ public:
     CharUnits EltSize =
         CharUnits::fromQuantity(DL.getTypeAllocSize(Addr.getElementType()));
 
-    return Address(
-        CreateGEP(Addr.getElementType(), Addr.getPointer(), Index, Name),
-        Addr.getElementType(),
-        Addr.getAlignment().alignmentOfArrayElement(EltSize));
+    llvm::Type *Ty = Addr.getElementType();
+    llvm::Value *ptr =
+        CreateGEP(Addr.getElementType(), Addr.getPointer(), Index, Name);
+    if (Ty->isStructTy()) {
+      llvm::Function *dropped_func =
+          TypeCache.get_dropped_function(Ty->getStructName());
+      llvm::ArrayRef<llvm::Value *> argv{ptr, Index};
+      ptr = CreateCall(dropped_func->getFunctionType(), dropped_func);
+    }
+
+    return Address(ptr, Addr.getElementType(),
+                   Addr.getAlignment().alignmentOfArrayElement(EltSize));
   }
 
   /// Given a pointer to i8, adjust it by a given constant offset.
diff --git a/clang/lib/CodeGen/CodeGenTypeCache.h b/clang/lib/CodeGen/CodeGenTypeCache.h
index e848dc3b4..0058b23d4 100644
--- a/clang/lib/CodeGen/CodeGenTypeCache.h
+++ b/clang/lib/CodeGen/CodeGenTypeCache.h
@@ -16,6 +16,8 @@
 #include "clang/AST/CharUnits.h"
 #include "clang/Basic/AddressSpaces.h"
 #include "llvm/IR/CallingConv.h"
+#include <llvm/ADT/DenseMap.h>
+#include <llvm/IR/Function.h>
 
 namespace llvm {
   class Type;
@@ -78,6 +80,16 @@ struct CodeGenTypeCache {
   /// void* in the address space for constant globals
   llvm::PointerType *ConstGlobalsPtrTy;
 
+  llvm::DenseMap<llvm::StringRef, llvm::Function *> dropped_functions;
+
+  void insert_dropped_function(llvm::StringRef name, llvm::Function *func) {
+    dropped_functions[name] = func;
+  }
+
+  llvm::Function *get_dropped_function(llvm::StringRef name) const {
+    return dropped_functions.lookup(name);
+  }
+
   /// The size and alignment of the builtin C type 'int'.  This comes
   /// up enough in various ABI lowering tasks to be worth pre-computing.
   union {
diff --git a/clang/lib/CodeGen/CodeGenTypes.cpp b/clang/lib/CodeGen/CodeGenTypes.cpp
index abbf71daf..cff85fa73 100644
--- a/clang/lib/CodeGen/CodeGenTypes.cpp
+++ b/clang/lib/CodeGen/CodeGenTypes.cpp
@@ -258,6 +258,8 @@ bool CodeGenTypes::isFuncTypeConvertible(const FunctionType *FT) {
   return true;
 }
 
+
+void emit_struct_dropped_func(llvm::Type *, CodeGen::CodeGenModule *);
 /// UpdateCompletedType - When we find the full definition for a TagDecl,
 /// replace the 'opaque' type we previously made for it if applicable.
 void CodeGenTypes::UpdateCompletedType(const TagDecl *TD) {
@@ -287,8 +289,10 @@ void CodeGenTypes::UpdateCompletedType(const TagDecl *TD) {
 
   // Only complete it if we converted it already.  If we haven't converted it
   // yet, we'll just do it lazily.
-  if (RecordDeclTypes.count(Context.getTagDeclType(RD).getTypePtr()))
-    ConvertRecordDeclType(RD);
+  if (RecordDeclTypes.count(Context.getTagDeclType(RD).getTypePtr())) {
+    llvm::StructType *Ty = ConvertRecordDeclType(RD);
+    emit_struct_dropped_func(Ty, &this->getCGM());
+  }
 
   // If necessary, provide the full definition of a type only used with a
   // declaration so far.
@@ -968,3 +972,58 @@ unsigned CodeGenTypes::getTargetAddressSpace(QualType T) const {
              ? getDataLayout().getProgramAddressSpace()
              : getContext().getTargetAddressSpace(T.getAddressSpace());
 }
+
+void emit_struct_dropped_func(llvm::Type *type, CodeGen::CodeGenModule *cgm) {
+  std::vector<llvm::Type *> func_parameters{cgm->IntPtrTy, cgm->Int32Ty};
+
+  llvm::FunctionType *function_type =
+      llvm::FunctionType::get(cgm->IntPtrTy, func_parameters, false);
+
+  llvm::Function *dropped_func = llvm::Function::Create(
+      function_type, llvm::GlobalValue::PrivateLinkage,
+      type->getStructName().str() + "_dropped_func", cgm->getModule());
+
+  dropped_func->getArg(0)->setName("ptr");
+  dropped_func->getArg(1)->setName("idx");
+  llvm::LLVMContext &context = dropped_func->getContext();
+  llvm::IRBuilder<> builder(context);
+
+  llvm::BasicBlock *init_block =
+      llvm::BasicBlock::Create(context, "init", dropped_func);
+  llvm::BasicBlock *if_then_block =
+      llvm::BasicBlock::Create(context, "if.then", dropped_func);
+  llvm::BasicBlock *if_else_block =
+      llvm::BasicBlock::Create(context, "if.else", dropped_func);
+
+  builder.SetInsertPoint(init_block);
+
+  llvm::Value *ptr_i32 = builder.CreatePtrToInt(
+      dropped_func->getArg(0), builder.getInt32Ty(), "ptr_i32");
+
+  // if (ptr > ptr_upper)
+  llvm::Constant *ptr_upper = builder.getInt32(1 * 1024 * 1024 * 1024);
+  llvm::Value *condition = builder.CreateICmpSLT(ptr_i32, ptr_upper);
+  builder.CreateCondBr(condition, if_then_block, if_else_block);
+
+  // return offset
+  builder.SetInsertPoint(if_then_block);
+  builder.CreateRet(dropped_func->getArg(0));
+
+  // else
+  builder.SetInsertPoint(if_else_block);
+
+  // dropped_offset = 4*idx;
+  llvm::Value *dropped_offset = builder.CreateMul(
+      dropped_func->getArg(1), builder.getInt32(4), "dropped_offset");
+  // new_ptr = ptr + dropped_offset;
+  llvm::Value *new_ptr_i32 =
+      builder.CreateAdd(ptr_i32, dropped_offset, "new_ptr_i32");
+  llvm::Value *new_ptr =
+      builder.CreateIntToPtr(new_ptr_i32, builder.getPtrTy(), "new_ptr");
+
+  // Value *new_offset = builder.getInt32(0);
+  //  return new_offset
+  builder.CreateRet(new_ptr);
+
+  cgm->insert_dropped_function(type->getStructName(), dropped_func);
+}
